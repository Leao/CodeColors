package io.leao.codecolors.core.color;

import android.app.Activity;
import android.content.res.ColorStateList;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.os.Build;
import android.support.annotation.ColorRes;
import android.util.SparseArray;

import java.lang.reflect.Field;
import java.util.Map;
import java.util.Set;

import io.leao.codecolors.core.color.CodeColor.AnchorCallback;
import io.leao.codecolors.core.color.CodeColor.SingleCallback;
import io.leao.codecolors.core.util.CcTempUtils;
import io.leao.codecolors.plugin.CcConst;

public class CcColorManager {
    private static final String CLASS_NAME_BASE = "%s.%s";

    private Map<Integer, Integer> mColorValue;

    private SparseArray<CcColorStateList> mColorCccsl = new SparseArray<>();

    private CcColorAdapter mColorAdapter;

    @SuppressWarnings("unchecked")
    public synchronized void init(String packageName)
            throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        /*
         * Initialize configurations and colors from the classes generated by the CodeColors plugin.
         */

        // CcColors.java
        Class<?> colorsClass =
                Class.forName(String.format(CLASS_NAME_BASE, packageName, CcConst.COLORS_CLASS_NAME));

        // Color value.
        Field colorValueField = colorsClass.getDeclaredField(CcConst.COLOR_VALUE_FIELD_NAME);
        colorValueField.setAccessible(true);
        mColorValue = (Map<Integer, Integer>) colorValueField.get(null);
    }

    public synchronized void onActivityCreated(Activity activity) {
        for (int colorResId : getColorIds()) {
            CcColorStateList color = getColor(colorResId);
            color.onActivityCreated(activity);
        }
    }

    public synchronized void onActivityResumed(Activity activity) {
        for (int colorResId : getColorIds()) {
            CcColorStateList color = getColor(colorResId);
            color.onActivityResumed(activity);
        }
    }

    public synchronized void onActivityPaused(Activity activity) {
        for (int colorResId : getColorIds()) {
            CcColorStateList color = getColor(colorResId);
            color.onActivityPaused(activity);
        }
    }

    public synchronized void onActivityDestroyed(Activity activity) {
        for (int colorResId : getColorIds()) {
            CcColorStateList color = getColor(colorResId);
            color.onActivityDestroyed(activity);
        }
    }

    public synchronized void onConfigurationCreated(Resources resources, Configuration configuration) {
        for (int colorResId : getColorIds()) {
            CcColorStateList color = getColor(colorResId);
            // Update color base color.
            updateBaseColor(resources, color, colorResId);

            // Call ColorAdapter, when defined.
            if (mColorAdapter != null) {
                mColorAdapter.onConfigurationCreated(configuration, color, colorResId);
            }
        }
    }

    public synchronized void onConfigurationChanged(Resources resources, Configuration configuration) {
        for (int colorResId : getColorIds()) {
            CcColorStateList color = getColor(colorResId);
            // Update color base color.
            updateBaseColor(resources, color, colorResId);

            // Call ColorAdapter, when defined.
            if (mColorAdapter != null) {
                mColorAdapter.onConfigurationChanged(configuration, color, colorResId);
            }
        }
    }

    /**
     * Call to {@link CcColorStateList#onBaseColorChanged(ColorStateList)}.
     */
    @SuppressWarnings("deprecation")
    protected void updateBaseColor(Resources resources, CcColorStateList color, int colorResId) {
        // Cancel animation, if isStarted (calls animation end).
        // Cancelling the animation, instead of ending it, might prevent an unnecessary call to invalidateSelf().
        color.cancelAnimation();

        // Configuration changed, get base color again, as it might have changed.
        ColorStateList baseColor;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            baseColor = resources.getColorStateList(mColorValue.get(colorResId), null);
        } else {
            baseColor = resources.getColorStateList(mColorValue.get(colorResId));
        }
        color.onBaseColorChanged(baseColor);
    }

    public synchronized Set<Integer> getColorIds() {
        return mColorValue.keySet();
    }

    public synchronized CcColorStateList getColor(@ColorRes int resId) {
        CcColorStateList color = mColorCccsl.get(resId);
        if (color == null && mColorValue.containsKey(resId)) {
            color = new CcColorStateList(resId);
            mColorCccsl.put(resId, color);
        }
        return color;
    }

    public synchronized void setColorAdapter(CcColorAdapter adapter) {
        mColorAdapter = adapter;
    }

    public synchronized void invalidate(CcColorStateList color) {
        Set<Reference<SingleCallback>> invalidatedSingleCallbacks = CallbackTempUtils.getSingleCallbackSet();
        Set<ReferencePair<Object, AnchorCallback>> invalidatedPairCallbacks = CallbackTempUtils.getPairCallbackSet();

        color.getCallbackHandlerManager().invalidate(invalidatedSingleCallbacks, invalidatedPairCallbacks);

        CallbackTempUtils.recycleSingleCallbackSet(invalidatedSingleCallbacks);
        CallbackTempUtils.recyclePairCallbackSet(invalidatedPairCallbacks);
    }

    public synchronized void invalidateMultiple(Set<CcColorStateList> colors) {
        Set<Reference<SingleCallback>> invalidatedSingleCallbacks = CallbackTempUtils.getSingleCallbackSet();
        Set<ReferencePair<Object, AnchorCallback>> invalidatedPairCallbacks = CallbackTempUtils.getPairCallbackSet();
        final Set<CcColorStateList> invalidateColors = CcTempUtils.getColorSet();

        for (CcColorStateList color : colors) {
            color.getCallbackHandlerManager()
                    .invalidateMultiple(colors, invalidatedSingleCallbacks, invalidatedPairCallbacks, invalidateColors);
        }

        CallbackTempUtils.recycleSingleCallbackSet(invalidatedSingleCallbacks);
        CallbackTempUtils.recyclePairCallbackSet(invalidatedPairCallbacks);
        CcTempUtils.recycleColorSet(invalidateColors);
    }
}
